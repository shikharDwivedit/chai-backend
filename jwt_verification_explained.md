# JWT Verification Explained

## ğŸ”‘ What happens when creating a token (JWT)
1. The server takes some **data** (like `userId: 123`).
2. It **encodes** that data into a JSON string.
3. It then **signs** it using the **secret key** (`ACCESS_TOKEN_SECRET`).

The signing step means:  
ğŸ‘‰ The server runs the data through a cryptographic algorithm (usually HMAC SHA256) **with the secret key** to generate a **signature**.  
ğŸ‘‰ This signature is attached to the token.

So the token looks like this (3 parts separated by `.`):
```
header.payload.signature
```

---

## ğŸ•µï¸ Now, when a request comes back with that token
1. The server receives the token.
2. It splits it into **header, payload, and signature**.
3. It **recalculates the signature** using:
   - the header + payload
   - the same secret key (`ACCESS_TOKEN_SECRET`).
4. If the recalculated signature == tokenâ€™s signature â†’ âœ… token is valid.
   - This proves the token **was generated by the server** and **hasnâ€™t been tampered with**.
5. If they donâ€™t match â†’ âŒ reject (invalid or altered token).

---

## âš¡ Why this works
Because only the server knows the **secret key**.  
If someone tries to modify the payload (like changing `userId: 123` to `userId: 999`), the signature check will fail.  

---

## âœ… Key Takeaways
- **Access token â‰  Access token secret**.  
- The **token** is the thing given to the client.  
- The **secret** never leaves the server â€” itâ€™s used internally to **verify** tokens.  
